--- a/lib/dwl/dwl.c	2025-12-27 06:22:19.186740584 -0800
+++ b/lib/dwl/dwl.c	2025-12-27 06:22:19.170997887 -0800
@@ -11,6 +11,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/wait.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
 #include <time.h>
 #include <unistd.h>
 #include <wayland-server-core.h>
@@ -352,6 +355,7 @@
 static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
 static void powermgrsetmode(struct wl_listener *listener, void *data);
+static void printstatus(void);
 static void quit(const Arg *arg);
 static void rendermon(struct wl_listener *listener, void *data);
 static void requestdecorationmode(struct wl_listener *listener, void *data);
@@ -459,6 +463,7 @@
 
 static char stext[256];
 static struct wl_event_source *status_event_source;
+static int status_fifo_fd = -1;
 
 static DBusConnection *bus_conn;
 static struct wl_event_source *bus_source;
@@ -1031,6 +1036,7 @@
 			setmon(c, selmon, c->tags);
 	}
 	focusclient(focustop(selmon), 1);
+	printstatus();
 	drawbars();
 }
 
@@ -1338,6 +1344,7 @@
 	else
 		wlr_output_layout_add(output_layout, wlr_output, m->m.x, m->m.y);
 
+	printstatus();
 	drawbars();
 }
 
@@ -1723,10 +1730,11 @@
 		x += w;
 	}
 
-	/* Draw status text in the middle area */
+	/* Draw status text centered in the middle area */
 	if (m == selmon && truncstatus[0]) {
+		int center_x = x + (statuswidth - tw) / 2;
 		drwl_setscheme(m->drw, colors[SchemeNorm]);
-		drwl_text(m->drw, x, 0, statuswidth, m->b.height, m->lrpad / 2, truncstatus, 0);
+		drwl_text(m->drw, center_x, 0, tw + m->lrpad, m->b.height, m->lrpad / 2, truncstatus, 0);
 	}
 
 	/* Draw systray at the right edge */
@@ -1835,6 +1843,7 @@
 			client_activate_surface(old, 0);
 		}
 	}
+	printstatus();
 	drawbars();
 
 	if (!c) {
@@ -2171,6 +2180,7 @@
 	} else {
 		applyrules(c);
 	}
+	printstatus();
 	drawbars();
 
 unset_fullscreen:
@@ -2514,6 +2524,44 @@
 }
 
 void
+printstatus(void)
+{
+	Monitor *m = NULL;
+	Client *c;
+	uint32_t occ, urg, sel;
+
+	wl_list_for_each(m, &mons, link) {
+		occ = urg = 0;
+		wl_list_for_each(c, &clients, link) {
+			if (c->mon != m)
+				continue;
+			occ |= c->tags;
+			if (c->isurgent)
+				urg |= c->tags;
+		}
+		if ((c = focustop(m))) {
+			printf("%s title %s\n", m->wlr_output->name, client_get_title(c));
+			printf("%s appid %s\n", m->wlr_output->name, client_get_appid(c));
+			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
+			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
+			sel = c->tags;
+		} else {
+			printf("%s title \n", m->wlr_output->name);
+			printf("%s appid \n", m->wlr_output->name);
+			printf("%s fullscreen \n", m->wlr_output->name);
+			printf("%s floating \n", m->wlr_output->name);
+			sel = 0;
+		}
+
+		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
+		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
+			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
+		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
+	}
+	fflush(stdout);
+}
+
+void
 quit(const Arg *arg)
 {
 	wl_display_terminate(dpy);
@@ -2640,6 +2688,7 @@
 	if (fd_set_nonblock(STDOUT_FILENO) < 0)
 		close(STDOUT_FILENO);
 
+	printstatus();
 	drawbars();
 
 	/* At this point the outputs are initialized, choose initial selmon based on
@@ -2706,6 +2755,7 @@
 			(p && p->isfullscreen) ? LyrFS
 			: c->isfloating ? LyrFloat : LyrTile]);
 	arrange(c->mon);
+	printstatus();
 	drawbars();
 }
 
@@ -2729,6 +2779,7 @@
 		resize(c, c->prev, 0);
 	}
 	arrange(c->mon);
+	printstatus();
 	drawbars();
 }
 
@@ -3029,8 +3080,28 @@
 
 	drwl_init();
 
-	status_event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
-		STDIN_FILENO, WL_EVENT_READABLE, statusin, NULL);
+	/* Open status FIFO for reading status updates */
+	{
+		const char *runtime_dir = getenv("XDG_RUNTIME_DIR");
+		char fifo_path[256];
+		if (runtime_dir)
+			snprintf(fifo_path, sizeof(fifo_path), "%s/dwl-status.fifo", runtime_dir);
+		else
+			snprintf(fifo_path, sizeof(fifo_path), "/tmp/dwl-status.fifo");
+
+		/* Create FIFO if it doesn't exist */
+		if (mkfifo(fifo_path, 0600) < 0 && errno != EEXIST)
+			wlr_log(WLR_ERROR, "Failed to create status FIFO: %s", strerror(errno));
+
+		/* Open FIFO with O_RDWR to prevent hangup when no writer connected */
+		status_fifo_fd = open(fifo_path, O_RDWR | O_NONBLOCK);
+		if (status_fifo_fd >= 0) {
+			status_event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
+				status_fifo_fd, WL_EVENT_READABLE, statusin, NULL);
+		} else {
+			wlr_log(WLR_INFO, "Status FIFO not available, status bar updates disabled");
+		}
+	}
 
 	bus_conn = dbus_bus_get(DBUS_BUS_SESSION, NULL);
 	if (!bus_conn)
@@ -3108,6 +3179,7 @@
 	status[strcspn(status, "\n")] = '\0';
 
 	strncpy(stext, status, sizeof(stext));
+	printstatus();
 	drawbars();
 
 	return 0;
@@ -3123,6 +3195,7 @@
 	sel->tags = arg->ui & TAGMASK;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
+	printstatus();
 	drawbars();
 }
 
@@ -3218,6 +3291,7 @@
 	sel->tags = newtags;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
+	printstatus();
 	drawbars();
 }
 
@@ -3231,6 +3305,7 @@
 	selmon->tagset[selmon->seltags] = newtagset;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
+	printstatus();
 	drawbars();
 }
 
@@ -3279,6 +3354,7 @@
 	}
 
 	wlr_scene_node_destroy(&c->scene->node);
+	printstatus();
 	drawbars();
 	motionnotify(0, NULL, 0, 0, 0, 0);
 }
@@ -3446,8 +3522,10 @@
 updatetitle(struct wl_listener *listener, void *data)
 {
 	Client *c = wl_container_of(listener, c, set_title);
-	if (c == focustop(c->mon))
+	if (c == focustop(c->mon)) {
+		printstatus();
 		drawbars();
+	}
 }
 
 void
@@ -3460,6 +3538,7 @@
 		return;
 
 	c->isurgent = 1;
+	printstatus();
 	drawbars();
 
 	if (client_surface(c)->mapped)
@@ -3476,6 +3555,7 @@
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
+	printstatus();
 	drawbars();
 }
 
@@ -3689,6 +3769,7 @@
 		return;
 
 	c->isurgent = xcb_icccm_wm_hints_get_urgency(c->surface.xwayland->hints);
+	printstatus();
 	drawbars();
 
 	if (c->isurgent && surface && surface->mapped)
